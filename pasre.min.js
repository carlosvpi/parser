!function e(t,r,n){function o(p,u){if(!r[p]){if(!t[p]){var l="function"==typeof require&&require;if(!u&&l)return l(p,!0);if(s)return s(p,!0);var c=new Error("Cannot find module '"+p+"'");throw c.code="MODULE_NOT_FOUND",c}var i=r[p]={exports:{}};t[p][0].call(i.exports,function(e){return o(t[p][1][e]||e)},i,i.exports,e,t,r,n)}return r[p].exports}for(var s="function"==typeof require&&require,p=0;p<n.length;p++)o(n[p]);return o}({1:[function(e,t,r){t.exports={pasre:e("./lib/parser"),getTraverser:e("./lib/traverse")}},{"./lib/parser":3,"./lib/traverse":5}],2:[function(e,t,r){const n=t.exports.MATCH=e=>{return(t,...r)=>{const o=t.match(e);return o&&0===o.index?[[n.type,o[0]],t.slice(o[0].length)]:[[null],t]}};n.type="$MATCH";const o=t.exports.LITERAL=e=>{return(t,...r)=>0===t.indexOf(e)?[[o.type,e],t.slice(e.length)]:[[null],t]};o.type="$LITERAL";const s=t.exports.CONCAT=(...e)=>{return(t,...r)=>{let n,o,p,u=[];const l=t;for(let s=0;s<e.length;s++){if([[p,...n],o]=e[s](t,...r),null===p)return[[null],l];t=o,u.push([p,...n])}return[[s.type,...u],t]}};s.type="$CONCAT";t.exports.DISJUNCTION=(...e)=>{return(t,...r)=>{let n,o,s;for(let p=0;p<e.length;p++)if([[s,...n],o]=e[p](t,...r),null!==s)return[[s,...n],o];return[[null],t]}},t.exports.OPTION=e=>{return(t,...r)=>{const[[n,...o],p]=e(t,...r);return o.length?[[n,...o],p]:[[s.type],t]}},t.exports.CLOSURE=e=>{return(t,...r)=>{let n,[[o,...p],u]=e(t,...r),l=[];for(;o;)l.push([o,...p]),o=(n=e(u,...r))[0][0],p=n[0].slice(1),u=n[1];return[[s.type,...l],u]}},t.exports.REPETITION=(e,t)=>{return(r,...n)=>{let o,p,u,l=[];for(let s=0;s<e;s++){if([[o,...p],u]=t(r,...n),!p.length)return[[null],r];r=u,l.push([o,...p])}return[[s.type,...l],r]}},t.exports.EXCEPTION=(e,t=(()=>[[null]]))=>{return(r,...n)=>{const[[o,...s],p]=e(r,...n),[[u,...l]]=t(r,...n);return!o||l.length?[[null],r]:[[o,...s],p]}},t.exports.EXPECT=(e,t,r=(e=>[[null],e]))=>{return(n,{original:o=n,errors:s=[],...p})=>{const u=e(n,{original:o,errors:s,...p});if(null===u[0][0]){const e=""===n?"end of input":`'${n.slice(0,20).split("\n").join("\\n")}...'`,p=""===n?o.split("\n"):o.slice(0,o.indexOf(n)).split("\n"),u=p.length,l=p[u-1].length;return s.push(`âœ˜ ${u}:${l} | Expected '${t}', got ${e}`),r(n)}return u}}},{}],3:[function(e,t,r){const{WS:n,WSs:o,NT:s,Conc:p,Xcep:u,Disj:l,Exp:c,Rule:i,EBNF:a}=e("./rules"),{MATCH:y,LITERAL:E,CONCAT:T,DISJUNCTION:f,OPTION:x,CLOSURE:h,REPETITION:C,EXCEPTION:O,EXPECT:N}=e("./hoc"),g=(t.exports.parser=(e,t={})=>{const r=[],n=a(e,{original:e,grammarErrors:r,...t});if(r.length)throw new Error(r.join("\n"),{grammar:e,parsedGrammar:n});const[[o,...s],p]=n,u=s.reduce((e,[t,r,n])=>(e[r]=(...t)=>{const o=g(n,e),[s,p]=o(...t);return[[r,s],p]},e),{});return Object.keys(u).reduce((e,t)=>(e[t]=(e,r={})=>{const n=[],o=u[t](e,{original:e,errors:n,...r});if(!Array.isArray(o))throw new Error("Unexpected error: invalid returned value. Please, report it to https://github.com/carlosvpi/pasre/issues",{result:o,hash:u,axiom:axiom,input:e});const[s,p]=o;if(n.length)throw new Error(n.join("\n"),{rawTree:s,rest:p});if(p)throw new Error(`Input continues after end of parsing: ${p.slice(0,50)}..., for a total of ${p.length} characters`,{rawTree:s,rest:p});return I(s)},e),{})},(e,t)=>{const[r,...i]=e,a=(e,r)=>{const n=g(e,t);return r?N(n):n};let I;switch(r){case c.type:I=(...e)=>{return f(...i.map(e=>g(e,t)))(...e)};break;case l.type:I=(...e)=>{return O(g(i[0],t),i[1]?g(i[1],t):void 0)(...e)};break;case u.type:I=(...e)=>{return T(...i.map(a))(...e)};break;case s.type:I=t[i[0]];break;case p.type.Repetition:I=C(i[0],g(i[1],t));break;case p.type.DblQuote:case p.type.SglQuote:I=E(i[0]);break;case p.type.Regex:I=(...e)=>{return y(i[0])(...e)};break;case p.type.Option:I=(...e)=>{return x(g(i[0],t))(...e)};break;case p.type.Closure:I=(...e)=>{return h(g(i[0],t))(...e)};break;case p.type.Group:I=(...e)=>{return g(i[0],t)(...e)};break;case n.type:I=n;break;case o.type:I=o;break;default:throw new Error("Unexpected error: invalid node type. Please, report it to https://github.com/carlosvpi/pasre/issues",{type:r,children:i,hash:t})}return I}),I=e=>e},{"./hoc":2,"./rules":4}],4:[function(e,t,r){const{MATCH:n,LITERAL:o,CONCAT:s,DISJUNCTION:p,OPTION:u,CLOSURE:l,REPETITION:c,EXCEPTION:i,EXPECT:a}=e("./hoc"),y=t.exports.WS=(...e)=>{const[[t],r]=n(/([\ \n\t]|\(\*.*\*\))/)(...e);return t?[[y.type],r]:[[null],r]};y.type="$WS";const E=t.exports.WSs=(...e)=>{const[t,r]=l(y)(...e);return[[E.type],r]};E.type="$WSs";const T=t.exports.NT=(...e)=>{const[[t,r],o]=s(n(/[a-zA-Z_][a-zA-Z0-9_]*/),E)(...e);return r?[[T.type,r[1]],o]:[[null],o]};T.type="$NT";const f=t.exports.Conc=(e,t={})=>{const[[r,...u],l]=p(T,s(n(/[0-9]+/),E,a(o("*"),"*"),E,a(T,"Non terminal")),s(o('"'),n(/[^\"]*/),a(o('"'),'"'),E),s(o("'"),n(/[^\']*/),a(o("'"),"'"),E),s(o("/"),n(/[^\/]*/),a(o("/"),"/"),E),s(o("["),E,C,a(o("]"),"]"),E),s(o("{"),E,C,a(o("}"),"}"),E),s(o("("),E,C,a(o(")"),")"),E),s(o("?"),a(t.special||(e=>e),"special rule"),a(o("?"),"?"),E))(e,t);return[null===r?[null]:r===T.type?[T.type,...u]:u[2][0]===o.type&&"*"===u[2][1]?[f.type.Repetition,u[0][1],u[4][1]]:u[0][0]===o.type&&'"'===u[0][1]?[f.type.DblQuote,u[1][1]]:u[0][0]===o.type&&"'"===u[0][1]?[f.type.SglQuote,u[1][1]]:u[0][0]===o.type&&"/"===u[0][1]?[f.type.Regex,u[1][1]]:u[0][0]===o.type&&"["===u[0][1]?[f.type.Option,u[2]]:u[0][0]===o.type&&"{"===u[0][1]?[f.type.Closure,u[2]]:u[0][0]===o.type&&"("===u[0][1]?[f.type.Group,u[2]]:[null],l]};f.type={},f.type.Repetition="$Repetition",f.type.DblQuote="$DblQuote",f.type.SglQuote="$SglQuote",f.type.Regex="$Regex",f.type.Option="$Option",f.type.Closure="$Closure",f.type.Group="$Group";const x=t.exports.Xcep=(...e)=>{const[[t,...r],n]=s(f,l(f))(...e);return null!==t?[[x.type,...r?[r[0],...r[1]?r[1].slice(1):[]]:[]],n]:[[null],n]};x.type="$Xcep";const h=t.exports.Disj=(...e)=>{const[[t,...r],n]=s(x,u(s(o("-"),E,a(x,'Expression after "-"'))))(...e);return null!==t?[[h.type,r[0],...r[1]&&r[1][1]?[r[1][3]]:[]],n]:[[null],n]};h.type="$Disj";const C=t.exports.Exp=(...e)=>{const[[t,...r],n]=s(h,l(s(o("|"),E,a(h,'Expression after "|"'))))(...e);return[[C.type,...r&&[r[0],...r[1]&&r[1]?r[1].slice(1).map(e=>e[3]):[]]],n]};C.type="$Exp";const O=t.exports.Rule=(...e)=>{const[[t,...r],n]=s(T,a(o("="),"="),E,a(C,'Expression after "="'),a(o(";"),";"),E)(...e),p=r&&r[0]&&r[0][1]||null,u=r&&r[3]||null;return p&&u?[[O.type,p,u],n]:[[null],n]};O.type="$Rule";const N=t.exports.EBNF=(...e)=>{const[[t,...r],n]=s(E,l(O))(...e);return[[N.type,...r[1].slice(1)],n]};N.type="$EBNF"},{"./hoc":2}],5:[function(e,t,r){const{MATCH:n,LITERAL:o,CONCAT:s,DISJUNCTION:p,OPTION:u,CLOSURE:l,REPETITION:c,EXCEPTION:i,EXPECT:a}=e("./hoc"),{WS:y,WSs:E,NT:T,Conc:f,Xcep:x,Disj:h,Exp:C,Rule:O,EBNF:N}=e("./rules"),g={[n.type]:(e,t)=>[t],[o.type]:(e,t)=>[t],[s.type]:(...e)=>e.reduce((e,t)=>Array.isArray(t)?[...e,...t]:[...e,t],[])},I=t.exports.getTraverser=(e={},t={})=>{const r={...g,...e};const n=([e,...o])=>{0;if(I.valueTypes.includes(e))return o;const s=("function"==typeof t[e]?t[e](...o):o).map(n);return"function"==typeof r[e]?r[e](...s):[]};return n};I.valueTypes=[n.type,o.type]},{"./hoc":2,"./rules":4}]},{},[1]);
