!function e(t,r,n){function o(s,u){if(!r[s]){if(!t[s]){var l="function"==typeof require&&require;if(!u&&l)return l(s,!0);if(p)return p(s,!0);var c=new Error("Cannot find module '"+s+"'");throw c.code="MODULE_NOT_FOUND",c}var i=r[s]={exports:{}};t[s][0].call(i.exports,function(e){return o(t[s][1][e]||e)},i,i.exports,e,t,r,n)}return r[s].exports}for(var p="function"==typeof require&&require,s=0;s<n.length;s++)o(n[s]);return o}({1:[function(e,t,r){t.exports=e("./lib/parser")},{"./lib/parser":3}],2:[function(e,t,r){const n=t.exports.MATCH=e=>(t,r)=>{const o=t.slice(r).match(e);return o&&0===o.index?[[n.type,...o],r+o[0].length]:[[null],r]};n.type="$MATCH";const o=t.exports.LITERAL=e=>(t,r)=>0===t.slice(r).indexOf(e)?[[o.type,e],r+e.length]:[[null],r];o.type="$LITERAL";const p=t.exports.CONCAT=(...e)=>(t,r,n)=>{let o,s,u,l=[];const c=r;for(let p=0;p<e.length;p++){if([[u,...o],s]=e[p](t,r,n),null===u)return[[null],c];r=s,l.push([u,...o])}return[[p.type,...l],r]};p.type="$CONCAT";t.exports.DISJUNCTION=(...e)=>(t,r,n)=>{let o,p,s;for(let u=0;u<e.length;u++)if([[s,...o],p]=e[u](t,r,n),null!==s)return[[s,...o],p];return[[null],r]},t.exports.OPTION=e=>(t,r,n)=>{const[[o,...s],u]=e(t,r,n);return s.length?[[o,...s],u]:[[p.type],r]},t.exports.CLOSURE=e=>(t,r,n)=>{let o,[[s,...u],l]=e(t,r,n),c=[];for(;s;)c.push([s,...u]),s=(o=e(t,l,n))[0][0],u=o[0].slice(1),l=o[1];return[[p.type,...c],l]},t.exports.REPETITION=(e,t)=>(r,n,o)=>{let s,u,l,c=[];for(let p=0;p<e;p++){if([[s,...u],l]=t(r,n,o),!u.length)return[[null],n];n=l,c.push([s,...u])}return[[p.type,...c],n]},t.exports.EXCEPTION=(e,t=(()=>[[null]]))=>(r,n,o)=>{const[[p,...s],u]=e(r,n,o),[[l,...c]]=t(r,n);return!p||c.length?[[null],n]:[[p,...s],u]},t.exports.EXPECT=(e,t,r=((e,t)=>[[null],t]))=>(n,o,p)=>{const s=e(n,o,p),[[u,...l],c]=s;if(null===u){const e=n.length<=c?"end of input":`'${n.slice(o,o+40).split("\n").join("\\n")}...'`,s=n.length<=c?n.split("\n"):n.slice(0,o).split("\n"),u=s.length,l=s[u-1].length;return p.push(`âœ˜ ${u}:${l} | Expected '${t}', got ${e}`),r(n,o)}return s}},{}],3:[function(e,t,r){const{WS:n,WSs:o,NT:p,Conc:s,Xcep:u,Disj:l,Exp:c,Rule:i,EBNF:a}=e("./rules"),{MATCH:y,LITERAL:x,CONCAT:h,DISJUNCTION:E,OPTION:f,CLOSURE:T,REPETITION:C,EXCEPTION:O,EXPECT:g}=e("./hoc"),N=(t.exports.parser=e=>{const t=[],r=a(e,0,t);if(t.length)throw new Error(t.join("\n"),{grammar:e,parsedGrammar:r});const[[n,...o],p]=r,s=o.reduce((e,[t,r,n])=>(e[r]=(t,o,p)=>{const s=N(n,e),[u,l]=s(t,o,p);return[[r,u],l]},e),{});return Object.keys(s).reduce((e,t)=>(e[t]=e=>{const r=[],n=s[t](e,0,r);if(!Array.isArray(n))throw new Error("Unexpected error: invalid returned value. Please, report it to https://github.com/carlosvpi/parser/issues",{result:n,hash:s,axiom:axiom,input:e});const[o,p]=n;if(r.length)throw new Error(r.join("\n"),{rawTree:rawTree,endIndex:p});if(p<e.length)throw new Error(`Input continues after end of parsing: ${e.slice(p,p+50)}..., for a total of ${e.length-p} characters`,{rawTree:rawTree,endIndex:p});return o},e),{})},(e,t)=>{const[r,...i]=e,a=(e,r)=>{const n=N(e,t);return r?g(n):n};switch(r){case c.type:return E(...i.map(e=>N(e,t)));case l.type:return O(N(i[0],t),i[1]?N(i[1],t):void 0);case u.type:return h(...i.map(a));case p.type:return t[i[0]];case s.type.Repetition:return C(i[0],N(i[1],t));case s.type.DblQuote:case s.type.SglQuote:return x(i[0]);case s.type.Regex:return y(i[0]);case s.type.Option:return f(N(i[0],t));case s.type.Closure:return T(N(i[0],t));case s.type.Group:return N(i[0],t);case n.type:return n;case o.type:return o;default:throw new Error("Unexpected error: invalid node type. Please, report it to https://github.com/carlosvpi/parser/issues",{type:r,children:i,hash:t})}})},{"./hoc":2,"./rules":4}],4:[function(e,t,r){const{MATCH:n,LITERAL:o,CONCAT:p,DISJUNCTION:s,OPTION:u,CLOSURE:l,REPETITION:c,EXCEPTION:i,EXPECT:a}=e("./hoc"),y=t.exports.WS=(e,t,r)=>{const[[o],p]=n(/([\ \n\t]|\(\*.*\*\))/)(e,t,r);return o?[[y.type],p]:[[null],p]};y.type="$WS";const x=t.exports.WSs=(e,t,r)=>{const[n,o]=l(y)(e,t,r);return[[x.type],o]};x.type="$WSs";const h=t.exports.NT=(e,t,r)=>{const[[o,s],u]=p(n(/[a-zA-Z_][a-zA-Z0-9_]*/),x)(e,t,r);return s?[[h.type,s[1]],u]:[[null],t]};h.type="$NT";const E=t.exports.Conc=(e,t,r)=>{const[[u,...l],c]=s(h,p(n(/[0-9]+/),x,a(o("*"),"*"),x,a(h,"Non terminal")),p(o('"'),n(/[^\"]*/),a(o('"'),'"'),x),p(o("'"),n(/[^\']*/),a(o("'"),"'"),x),p(o("/"),n(/[^\/]*/),a(o("/"),"/"),x),p(o("["),x,C,a(o("]"),"]"),x),p(o("{"),x,C,a(o("}"),"}"),x),p(o("("),x,C,a(o(")"),")"),x),p(o("?"),n(/[^\?]*/),a(o("?"),"?"),x))(e,t,r);return[null===u?[null]:u===h.type?[h.type,...l]:l[2][0]===o.type&&"*"===l[2][1]?[E.type.Repetition,l[0][1],l[4][1]]:l[0][0]===o.type&&'"'===l[0][1]?[E.type.DblQuote,l[1][1]]:l[0][0]===o.type&&"'"===l[0][1]?[E.type.SglQuote,l[1][1]]:l[0][0]===o.type&&"/"===l[0][1]?[E.type.Regex,l[1][1]]:l[0][0]===o.type&&"["===l[0][1]?[E.type.Option,l[2]]:l[0][0]===o.type&&"{"===l[0][1]?[E.type.Closure,l[2]]:l[0][0]===o.type&&"("===l[0][1]?[E.type.Group,l[2]]:[null],c]};E.type={Repetition:"$Repetition",DblQuote:"$DblQuote",SglQuote:"$SglQuote",Regex:"$Regex",Option:"$Option",Closure:"$Closure",Group:"$Group"};const f=t.exports.Xcep=(e,t,r)=>{const[[n,...o],s]=p(E,l(E))(e,t,r);return null!==n?[[f.type,...o?[o[0],...o[1]?o[1].slice(1):[]]:[]],s]:[[null],s]};f.type="$Xcep";const T=t.exports.Disj=(e,t,r)=>{const[[n,...s],l]=p(f,u(p(o("-"),x,a(f,'Expression after "-"'))))(e,t,r);return null!==n?[[T.type,s[0],...s[1]&&s[1][1]?[s[1][3]]:[]],l]:[[null],l]};T.type="$Disj";const C=t.exports.Exp=(e,t,r)=>{const[[n,...s],u]=p(T,l(p(o("|"),x,a(T,'Expression after "|"'))))(e,t,r);return[[C.type,...s&&[s[0],...s[1]&&s[1]?s[1].slice(1).map(e=>e[3]):[]]],u]};C.type="$Exp";const O=t.exports.Rule=(e,t,r)=>{const[[n,...s],u]=p(h,a(o("="),"="),x,a(C,'Expression after "="'),a(o(";"),";"),x)(e,t,r),l=s&&s[0]&&s[0][1]||null,c=s&&s[3]||null;return l&&c?[[O.type,l,c],u]:[[null],t]};O.type="$Rule";const g=t.exports.EBNF=(e,t,r)=>{const[[n,...o],s]=p(x,l(O))(e,t,r);return[[g.type,...o[1].slice(1)],s]};g.type="$EBNF"},{"./hoc":2}]},{},[1]);
